#
# Sends an ABM out each of the QSFP ports
#
# A "pattern" is a 32-bit integer.  In the ABM that gets output, the upper
# 16-bits of the pattern will be repeated 32 times, then the lower 16-bits
# of the pattern will be repeated 32 times, with ths sequence repeating for
# the entire length of the ABM.
#
# Each of the two QSFP ports requires a pattern.
#
# This script and the RTL design it uses were written by D. Wolf
#


# Define the RTL registers
REG_RTL_ID=0x0014
BASE_ADDR=0x1000
     REG_PATTERN0=$((BASE_ADDR + 0*4));
     REG_PATTERN1=$((BASE_ADDR + 1*4));
REG_START_PATTERN=$((BASE_ADDR + 2*4));
    REG_START_DMA=$((BASE_ADDR + 3*4));
   REG_RUN_STATUS=$((BASE_ADDR + 4*4));
  REG_QSFP_STATUS=$((BASE_ADDR + 5*4));
   REG_DMA_ADDR0H=$((BASE_ADDR + 6*4));
   REG_DMA_ADDR0L=$((BASE_ADDR + 7*4));
   REG_DMA_ADDR1H=$((BASE_ADDR + 8*4));
   REG_DMA_ADDR1L=$((BASE_ADDR + 9*4));


# Fetch the bitmap patterns from the command line and assign defaults
pattern0=$1
pattern1=$2
test -z $pattern0 && pattern0=0xAA00AA00
test -z $pattern1 && pattern1=0x00CC00CC

# Make sure we have the correct RTL loaded
if [ $(pcireg -dec $REG_RTL_ID) -ne 6142024 ]; then
    echo "abm_gen RTL not loaded" 1>&2
    exit 1
fi

# Fetch the "PCS alignment" status bits
aligned=$(pcireg -dec $REG_QSFP_STATUS)

# Tell the user if one of the cables isn't plugged in
test $((aligned & 1)) -eq 0 && echo "QSFP_0 appears disconnected!" 1>&2
test $((aligned & 2)) -eq 0 && echo "QSFP_1 appears disconnected!" 1>&2
test $aligned -ne 3 && exit 1

# Ensure that we're not currently sending an ABM
while [ $(pcireg -dec $REG_RUN_STATUS) -ne 0 ]; do
    sleep .01
done

# Program the two patterns we want to send
pcireg $REG_PATTERN0 $pattern0
pcireg $REG_PATTERN1 $pattern1

# Send the ABM
pcireg $REG_START_PATTERN 1

# Wait for the send to complete
while [ $(pcireg -dec $REG_RUN_STATUS) -ne 0 ]; do
    sleep .01
done

